<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <title>Leaflet Campus Map — Optimized</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Red+Hat+Text:ital,wght@0,400;0,600;0,700;1,400&family=Noto+Sans+KR:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous" />
    <style>
        :root {
            --header-height: 64px;
            --bar-bg: #AD1D19;
            --bar-fg: #fff;
            --bar-shadow: 0 1px 8px rgba(0, 0, 0, .08);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        /* Map sits below the fixed top bar */
        #map {
            position: fixed;
            top: var(--header-height);
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Top bar */
        .topbar {
            position: fixed;
            inset: 0 0 auto 0;
            height: var(--header-height);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            background: var(--bar-bg);
            color: var(--bar-fg);
            box-shadow: var(--bar-shadow);
            z-index: 1000;
            user-select: none;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 0;
        }

        .brand-logo {
            height: 64px;
            object-fit: contain;
        }

        /* Simple divIcons */
        .parking-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #3366cc;
            color: #fff;
            font-weight: 700;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }

        .gate-icon {
            width: 28px;
            height: 28px;
            text-align: center;
            line-height: 24px;
            font-weight: 700;
            color: #808080;
            font-size: 28px;
        }

        /* Labels */
        .label {
            pointer-events: none;
            font-size: 15px;
            font-family: "Red Hat Text", "Noto Sans KR", system-ui, sans-serif;
            color: #000;
            white-space: nowrap;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        }

        /* Popup */
        .bldg-popup .popup-desc {
            margin-top: 6px;
            color: #333;
            line-height: 1.45;
        }

        .bldg-popup .popup-links {
            margin: 6px 0 0;
            padding-left: 16px;
        }

        .bldg-popup .popup-links li {
            margin: 2px 0;
        }

        .bldg-popup .popup-links a {
            font-size: 12px;
            color: #2a6;
            text-decoration: underline;
            word-break: break-all;
        }

        .bldg-popup .popup-imgs {
            margin-top: 6px;
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding-bottom: 2px;
        }

        .bldg-popup .popup-imgs img {
            width: 200px;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, .12);
            flex: 0 0 auto;
        }

        @media (max-width:420px) {
            .bldg-popup .popup-imgs img {
                width: 120px;
                height: 78px;
            }
        }

        /* Language switch */
        .lang-switch {
            display: flex;
            gap: 8px;
        }

        .lang-btn {
            background: rgba(255, 255, 255, .9);
            border: 0;
            padding: 6px 10px;
            border-radius: 8px;
            font: 600 14px/1 "Red Hat Text", "Noto Sans KR", system-ui, sans-serif;
            cursor: pointer;
        }

        .lang-btn.active {
            outline: 2px solid #fff;
        }

        /* Legend (featured buildings) */
        .legend-control {
            background: rgba(255, 255, 255, .5);
            padding: 10px;
            border-radius: 10px;
            box-shadow: var(--bar-shadow);
            max-width: 280px;
            font-family: "Red Hat Text", "Noto Sans KR", system-ui, sans-serif;
        }

        .legend-control h3 {
            margin: 0 0 6px;
            font-weight: 900;
            color: rgba(13, 50, 111);
            font-size: 15px;
        }

        .legend-item {
            display: block;
            width: 100%;
            text-align: left;
            border: 0;
            background: transparent;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            font: 00 13px/1.2 "Red Hat Text", "Noto Sans KR", system-ui, sans-serif;
        }

        .legend-item:hover {
            background: rgba(0, 0, 0, .06);
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>

    <!-- Top bar -->
    <header class="topbar" role="banner" aria-label="Campus header">
        <div class="brand">
            <img src="./data/kyungheelogo.jpg" alt="학교 로고" class="brand-logo" id="schoolLogo" />
        </div>
        <div class="lang-switch" role="group" aria-label="Language switch">
            <button type="button" class="lang-btn" data-lang="ko">한국어</button>
            <button type="button" class="lang-btn" data-lang="en">English</button>
        </div>
    </header>

    <div id="map" aria-label="Campus map"></div>

    <script>
        // ================== Map base ==================
        const map = L.map('map', { center: [37.595719, 127.05373], zoom: 16, minZoom: 16, maxZoom: 20 });
        map.zoomControl.setPosition('topright');
        // Fix potential initial layout race: ensure Leaflet recalculates size
        window.addEventListener('load', () => map.invalidateSize());
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap contributors & CartoDB', subdomains: 'abcd', maxZoom: 20
        }).addTo(map);

        // SVG defs for pattern fills (must exist before layers mount)
        const svgRenderer = L.svg();
        map.addLayer(svgRenderer);
        const svg = svgRenderer._container;
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
      <pattern id="parkingHatch" patternUnits="userSpaceOnUse" width="6" height="6" patternTransform="rotate(30)">
        <rect width="8" height="8" fill="#e2ddda"></rect>
        <rect width="4" height="8" fill="#c9c1bc" opacity="0.7"></rect>
      </pattern>
      <pattern id="forestDots" patternUnits="userSpaceOnUse" width="6" height="6">
        <rect width="8" height="8" fill="#bfcd96"></rect>
        <circle cx="2" cy="2" r="1" fill="#aab884" opacity="0.7"></circle>
        <circle cx="6" cy="6" r="1" fill="#aab884" opacity="0.7"></circle>
      </pattern>`;
        svg.prepend(defs);

        // Ensure pattern URL works across browsers (absolute ref)
        const patternRef = (id) => `url(${location.href.split('#')[0]}#${id})`;

        // ================== Language state ==================
        let currentLang = 'ko';
        const updateLangButtons = () => {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                const on = btn.dataset.lang === currentLang;
                btn.classList.toggle('active', on);
                btn.setAttribute('aria-pressed', on ? 'true' : 'false');
            });
        };
        const setLang = (lang) => {
            if (lang !== 'ko' && lang !== 'en') return;
            currentLang = lang;
            localStorage.setItem('lang', lang);
            updateLangButtons();
            // Refresh building labels
            if (window._refreshBuildingLabels) window._refreshBuildingLabels();
            if (window._updateLegendText) window._updateLegendText();
            // Refresh other labels
            if (window._labelLayers) {
                window._labelLayers.forEach(({ layer, feature }) => {
                    if (!layer._label) return;
                    const p = feature.properties || {};
                    const name = (currentLang === 'en') ? (p.int_name || p.name || '') : (p['simplified name'] || p.name || '');
                    const html = name ? `<div style="text-align:center;">${String(name).replace(/\(/g, (m, off) => off === 0 ? '(' : '<br>(')}</div>` : '';
                    setLabelText(layer._label, html);
                });
            }
            // Refresh open popup content
            // Refresh open popup content (layer-specific)
            if (highlightedLayer) {
                const { layer, layerGroup, descKey } = highlightedLayer;
                const f = layer?.feature;
                if (f) {
                    const key = descKey || layerGroup?._desc_key || null;
                    const popup = map._popup;
                    if (!popup) return;

                    // 제목은 즉시 갱신
                    popup.setContent(buildNameHtml(f));

                    // 레이어별 JSON 준비 후 본문/링크/이미지 갱신
                    ensureDescLoaded(key).then(() => {
                        const entry = key ? getDescEntryFor(key, f) : null;
                        const desc = getEntryText(entry);
                        const extras = buildLinkAndImagesHtml(entry, f);
                        if (desc || extras) {
                            popup.setContent(buildNameHtml(f) + buildDescHtml(desc) + extras);
                        }
                    });
                }
            }

        };
        document.addEventListener('click', (e) => { const btn = e.target.closest('.lang-btn'); if (btn) setLang(btn.dataset.lang); });
        updateLangButtons();

        // ================== Utilities ==================
        let highlightedLayer = null; // { layer, layerGroup }

        // === Per-layer descriptions (resilient fetch + cache) ===
        const DESC_SOURCES = {
            building: './data/building_desc.json',
            playground: './data/playground_desc.json',
            stairstatue: './data/stairstatue_desc.json',
            gate: './data/gate_desc.json',
            parkinglot: './data/parkinglot_desc.json',
        };

        const LAYER_DESCS = {};   // key -> { fid: entry }
        const DESC_READY = {};   // key -> Promise

        async function fetchJSON(url, { retries = 2, timeout = 10000, cache = 'no-store' } = {}) {
            for (let i = 0; i <= retries; i++) {
                try {
                    const ctrl = new AbortController();
                    const t = setTimeout(() => ctrl.abort(), timeout);
                    const r = await fetch(resolveAsset(url), { cache, signal: ctrl.signal });
                    clearTimeout(t);
                    if (!r.ok) throw new Error('HTTP ' + r.status);
                    return await r.json();
                } catch (err) {
                    if (i === retries) throw err;
                    await new Promise(res => setTimeout(res, 300 * (i + 1) + Math.random() * 300));
                }
            }
        }

        function ensureDescLoaded(key) {
            if (!key || !DESC_SOURCES[key]) return Promise.resolve();
            if (DESC_READY[key]) return DESC_READY[key];
            DESC_READY[key] = fetchJSON(DESC_SOURCES[key])
                .then(json => { LAYER_DESCS[key] = json || {}; })
                .catch(err => { console.warn(`${key} desc load failed:`, err); LAYER_DESCS[key] = {}; });
            return DESC_READY[key];
        }

        function getDescEntryFor(key, feature) {
            const fid = feature?.properties?.fid;
            if (fid == null) return null;
            return (LAYER_DESCS[key] || {})[String(fid)] || null;
        }


        const resolveAsset = (path) => new URL(String(path), document.baseURI).href;
        const buildNameHtml = (feature) => {
            const p = feature?.properties ?? {};
            const ko = p.name ?? '이름 없음';
            const en = p.int_name ?? '';
            const title = (currentLang === 'en') ? (en || ko || 'No name') : (ko || en || '이름 없음');
            return `<b>${title}</b>`;
        };
        const getDescEntry = (feature) => {
            const fidKey = feature?.properties?.fid != null ? String(feature.properties.fid) : null;
            return fidKey ? BUILDING_DESC[fidKey] : null;
        };
        const getEntryText = (entry) => {
            if (!entry) return '';
            if (typeof entry === 'string') return entry;
            return (currentLang === 'en') ? (entry.en || entry.ko || '') : (entry.ko || entry.en || '');
        };
        const formatText = (s) => String(s).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
        const buildDescHtml = (desc) => {
            if (!desc) return '';
            if (Array.isArray(desc)) return `<div class="popup-desc">${desc.map(p => `<p>${formatText(p)}</p>`).join('')}</div>`;
            return `<div class="popup-desc">${formatText(desc)}</div>`;
        };
        const escapeHTML = (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        const buildLinkAndImagesHtml = (entry, feature) => {
            if (!entry || typeof entry === 'string') return '';
            const parts = [];
            const langIsKo = (currentLang === 'ko');
            const linksCollected = [];
            if (Array.isArray(entry.links)) {
                entry.links.forEach(item => {
                    if (!item) return;
                    const url = item.url || item.href || '';
                    const label = item.label || (langIsKo ? item.label_ko : item.label_en) || item.label_ko || item.label_en || (langIsKo ? '링크' : 'Link');
                    if (url) linksCollected.push({ label, url });
                });
            } else if (entry.links && typeof entry.links === 'object') {
                for (const [label, url] of Object.entries(entry.links)) { if (url) linksCollected.push({ label, url }); }
            }
            if (entry.link && linksCollected.length === 0) linksCollected.push({ label: langIsKo ? '공식 페이지' : 'Official site', url: entry.link });
            if (linksCollected.length) {
                const list = linksCollected.map(({ label, url }) => `<li><a href="${resolveAsset(url)}" target="_blank" rel="noopener">${escapeHTML(label)}</a></li>`).join('');
                parts.push(`<ul class="popup-links">${list}</ul>`);
            }
            const imgs = Array.isArray(entry.img) ? entry.img : (entry.img ? [entry.img] : []);
            if (imgs.length) {
                const name = feature?.properties?.name ?? '';
                const gallery = imgs.map((src, i) => `<img src="${resolveAsset(src)}" alt="${escapeHTML(name ? name + ' 이미지 ' : '')}${i + 1}" loading="lazy">`).join('');
                parts.push(`<div class="popup-imgs">${gallery}</div>`);
            }
            return parts.join('');
        };

        const rememberStyle = (l) => { if (!l._origStyle && l.options && typeof l.setStyle === 'function') l._origStyle = { ...l.options }; };
        const restoreStyle = (group, l) => {
            const hasGeoJsonStyle = !!(group && typeof group.resetStyle === 'function' && group.options?.style);
            if (hasGeoJsonStyle) group.resetStyle(l); else if (l._origStyle && typeof l.setStyle === 'function') l.setStyle(l._origStyle);
        };
        const clearHighlight = () => {
            if (!highlightedLayer) return;
            const { layerGroup, layer } = highlightedLayer;
            try { restoreStyle(layerGroup, layer); } catch { }
            highlightedLayer = null; map.closePopup();
        };
        // const applyHighlight = (layerGroup, layer, e, feature) => {

        // 기존 함수 교체
        const applyHighlight = (layerGroup, layer, e, feature, descKey, popupOpts = {}) => {
            try { L.DomEvent.stop(e); } catch { }
            clearHighlight();

            if (layer && typeof layer.setStyle === 'function') {
                layer.setStyle({ color: '#ff6600', weight: 0, fillColor: '#ffa500', fillOpacity: 0.9 });
                layer.bringToFront && layer.bringToFront();
            }

            const popup = L.popup({
                maxWidth: 380,
                className: 'bldg-popup',
                // 여기서 autoPan을 외부에서 제어할 수 있게
                ...popupOpts
            })
                .setLatLng(e.latlng)
                .setContent(buildNameHtml(feature))
                .openOn(map);

            const key = descKey || layerGroup?._desc_key;
            ensureDescLoaded(key).then(() => {
                const entry = key ? getDescEntryFor(key, feature) : null;
                const desc = getEntryText(entry);
                const extras = buildLinkAndImagesHtml(entry, feature);
                if (desc || extras) popup.setContent(buildNameHtml(feature) + buildDescHtml(desc) + extras);
            });

            highlightedLayer = { layer, layerGroup, descKey: key };
        };


        // Background click / ESC to clear highlight
        map.on('click', clearHighlight);
        map.getContainer().tabIndex = 0;
        map.getContainer().addEventListener('keydown', (ev) => { if (ev.key === 'Escape') clearHighlight(); });

        // Label helpers
        const createLabelForFeature = (feature, html = '', className = 'label') => {
            const p = feature?.properties ?? {};
            const lat = p.centeroid_ycoord, lng = p.centeroid_xcoord;
            if (typeof lat !== 'number' || typeof lng !== 'number') return null;
            return L.marker([lat, lng], { icon: L.divIcon({ className, html, iconSize: null, iconAnchor: [30, 10] }), interactive: false });
        };
        const setLabelText = (labelMarker, html = '', className = 'label') => {
            if (!labelMarker) return;
            labelMarker.setIcon(L.divIcon({ className, html, iconSize: null, iconAnchor: [30, 10] }));
        };

        // Store non-building labels for language refresh
        window._labelLayers = [];

        // ================== Layer loading ==================
        // Campus area (non-interactive)
        fetch('./data/campusarea.geojson').then(r => r.json()).then(campusarea => {
            L.geoJSON(campusarea, {
                renderer: svgRenderer,
                interactive: false,
                style: (f) => ({ color: 'black', weight: 0, fillColor: f.properties.fid === 1 ? '#e7ebc7' : (f.properties.fid === 2 ? '#f3d3d4' : 'gray'), fillOpacity: 1 })
            }).addTo(map);
        }).catch(console.error);

        // Buildings (interactive + zoom/locale-aware labels)
        fetch('./data/building.geojson').then(r => r.json()).then(data => {
            const buildingLayer = L.geoJSON(data, {
                renderer: svgRenderer,
                style: { color: '#b6afa9', weight: 1, fillColor: '#c6beb8', fillOpacity: 1 },
                onEachFeature: (feature, layer) => {
                    rememberStyle(layer);
                    layer.on('click', (e) => applyHighlight(buildingLayer, layer, e, feature, 'building'));
                    layer._label = createLabelForFeature(feature, ''); // initially empty
                }
            }).addTo(map);

            buildingLayer._desc_key = 'building';
            const handleZoom = () => {
                const z = map.getZoom();
                const isEn = (currentLang === 'en');
                buildingLayer.eachLayer(l => {
                    const p = l.feature?.properties ?? {}; const fid = p.fid; if (!l._label) return;
                    let show = false, text = '', name = '';
                    if (z === 16 || z === 17) {
                        if ([2, 4, 58, 62].includes(fid)) { name = isEn ? (p.int_name || '') : (p['simplified name'] || p.name || ''); show = !!name; text = name ? `<div style="text-align:center;">${String(name)}</div>` : ''; }
                    } else if (z === 18) {
                        if (![26, 47, 48, 49, 50, 52].includes(fid)) { name = isEn ? (p.int_name || '') : (p['simplified name'] || ''); if (name) { const pretty = String(name).replace(/\(/g, (m, off) => off === 0 ? '(' : '<br>('); text = `<div style="text-align:center;">${pretty}</div>`; show = true; } }
                    } else if (z >= 19) {
                        name = isEn ? (p.int_name || p.name || '') : (p.name || p['simplified name'] || '');
                        if (name) { const pretty = String(name).replace(/\(/g, (m, off) => off === 0 ? '(' : '<br>('); text = `<div style=\"text-align:center;\">${pretty}</div>`; show = true; }
                    }
                    if (show) { setLabelText(l._label, text); if (!map.hasLayer(l._label)) l._label.addTo(map); }
                    else { if (map.hasLayer(l._label)) map.removeLayer(l._label); }
                });
            };
            window._refreshBuildingLabels = handleZoom;
            map.on('zoomend', handleZoom); handleZoom();
            // === (A) 범례에 노출할 '대표 건물' 선정 (fid 기반) ===
            // 필요에 맞게 fid를 넣어줘. 라벨을 강제로 덮어쓰고 싶으면 labelKo/labelEn 넣기.
            const FEATURED_BUILDINGS = [
                { fid: 4 }, { fid: 2 }, { fid: 58 }, { fid: 62 },
                { fid: 12 }, { fid: 1 }, { fid: 20 }, { fid: 9 },
                { fid: 15 }, { fid: 5 }, { fid: 21 }, { fid: 17 },
                { fid: 31 }, { fid: 43 }, { fid: 24 }, { fid: 18 },
                { fid: 34 }, { fid: 46 }, { fid: 11 }, { fid: 14 },
                { fid: 8 }, { fid: 19 }, { fid: 65 }, { fid: 42 },
                { fid: 40 }
                // 예: { fid: 123, labelKo: "본관", labelEn: "Main Building" }
            ];

            // === (B) 빠른 탐색을 위해 fid -> 레이어 인덱스 만들기 ===
            const buildingIndex = new Map();
            buildingLayer.eachLayer(l => {
                const fid = l?.feature?.properties?.fid;
                if (fid != null) buildingIndex.set(fid, l);
            });

            // === (C) 팝업 지점(중심) 계산기 ===
            function featureCenter(layer) {
                const p = layer?.feature?.properties ?? {};
                const lat = p.centeroid_ycoord, lng = p.centeroid_xcoord;
                if (typeof lat === 'number' && typeof lng === 'number') return L.latLng(lat, lng);
                try { return layer.getBounds().getCenter(); } catch { return map.getCenter(); }
            }

            // === (D) 버튼 라벨 생성기(언어 반영) ===
            function buildingLabelFor(fid) {
                const layer = buildingIndex.get(fid);
                const f = layer?.feature; const p = f?.properties || {};
                const forced = FEATURED_BUILDINGS.find(x => x.fid === fid) || {};
                if (currentLang === 'en') return forced.labelEn || p.int_name || p.name || `FID ${fid}`;
                return forced.labelKo || p['simplified name'] || p.name || `FID ${fid}`;
            }

            // === (E) Leaflet 컨트롤로 범례 UI 만들기 ===
            const legendLinks = []; // 언어 전환 시 텍스트 갱신용
            const LegendControl = L.Control.extend({
                options: { position: 'topleft' }, // 필요시 'topright' 등으로 변경
                onAdd: function () {
                    const div = L.DomUtil.create('div', 'legend-control');
                    L.DomEvent.disableClickPropagation(div); // 지도 드래그와 분리

                    const title = document.createElement('h3');
                    title.textContent = (currentLang === 'en') ? 'Featured Buildings' : '대표 건물';
                    div.appendChild(title);

                    FEATURED_BUILDINGS.forEach(({ fid }) => {
                        const layer = buildingIndex.get(fid);
                        if (!layer) return;

                        const btn = document.createElement('button');
                        btn.className = 'legend-item';
                        btn.type = 'button';
                        btn.textContent = buildingLabelFor(fid);
                        btn.setAttribute('data-fid', String(fid));
                        btn.onclick = () => {
                            const b = layer.getBounds && layer.getBounds();
                            if (b && b.isValid && b.isValid()) {
                                // 1) 건물 전체가 보이도록, 그리고 지도의 '정중앙'에 오도록
                                map.flyToBounds(b, { maxZoom: 17, padding: [80, 80], animate: true });

                                // 2) 이동이 끝난 뒤, 정확한 중앙에서 팝업/하이라이트
                                map.once('moveend', () => {
                                    const center = b.getCenter();
                                    applyHighlight(
                                        buildingLayer,
                                        layer,
                                        { latlng: center },   // 팝업도 중앙에서 뜨게
                                        layer.feature,
                                        'building',
                                        { autoPan: false }    // 팝업 열 때 자동 패닝 금지 → 중심 유지
                                    );
                                });
                            } else {
                                // 예비: bounds가 없으면 centroid 기반
                                const center = featureCenter(layer);
                                map.setView(center, Math.max(map.getZoom(), 18), { animate: true });
                                applyHighlight(buildingLayer, layer, { latlng: center }, layer.feature, 'building', { autoPan: false });
                            }
                        };

                        div.appendChild(btn);
                        legendLinks.push(btn);
                    });

                    return div;
                }
            });
            map.addControl(new LegendControl());

            // (선택) 첫 클릭 지연 방지: 설명 JSON 미리 로드
            ensureDescLoaded('building');

            // === (F) 언어 전환 시 범례 텍스트도 갱신 ===
            window._updateLegendText = () => {
                // 제목 갱신
                const titles = document.querySelectorAll('.legend-control h3');
                titles.forEach(h =>
                    h.textContent = (currentLang === 'en') ? 'Building Location' : '위치 찾기'
                );
                // 항목 갱신
                legendLinks.forEach(btn => {
                    const fid = Number(btn.getAttribute('data-fid'));
                    btn.textContent = buildingLabelFor(fid);
                });
            };

        }).catch(console.error);

        // Parking (polygon hatch, non-interactive)
        fetch('./data/parking.geojson').then(r => r.json()).then(data => {
            L.geoJSON(data, {
                renderer: svgRenderer,
                interactive: false,
                style: { color: '#a8a09a', weight: 0, fillOpacity: 1 },
                onEachFeature: (_, layer) => { layer.on('add', () => { const el = layer.getElement(); if (el) el.setAttribute('fill', patternRef('parkingHatch')); }); }
            }).addTo(map);
        }).catch(console.error);

        // Forest (polygon dots, non-interactive)
        fetch('./data/forest.geojson').then(r => r.json()).then(data => {
            L.geoJSON(data, {
                renderer: svgRenderer,
                interactive: false,
                style: { color: '#a8a09a', weight: 0, fillOpacity: 1 },
                onEachFeature: (_, layer) => { layer.on('add', () => { const el = layer.getElement(); if (el) el.setAttribute('fill', patternRef('forestDots')); }); }
            }).addTo(map);
        }).catch(console.error);

        // Grass (non-interactive)
        fetch('./data/grass.geojson').then(r => r.json()).then(data => {
            L.geoJSON(data, {
                renderer: svgRenderer,
                interactive: false,
                style: { color: '#a8a09a', weight: 0, fillColor: '#cdd7a5', fillOpacity: 1 }
            }).addTo(map);
        }).catch(console.error);

        // Pond (non-interactive)
        fetch('./data/pond.geojson').then(r => r.json()).then(data => {
            L.geoJSON(data, {
                renderer: svgRenderer,
                interactive: false,
                style: { color: '#a9bed1', weight: 2, fillColor: '#b8cee3', fillOpacity: 1 }
            }).addTo(map);
        }).catch(console.error);

        // Stair/Statue (partial interactive: fid === 3)
        fetch('./data/stairstatue.geojson').then(r => r.json()).then(data => {
            const stairstatue = L.geoJSON(data, {
                renderer: svgRenderer,
                style: { color: '#a8a09a', weight: 0, fillColor: '#ecebda', fillOpacity: 1 },
                onEachFeature: (feature, layer) => {
                    if (feature.properties?.fid === 3) {
                        rememberStyle(layer);
                        // (1) onEachFeature 내부: 클릭 핸들러에 descKey 추가
                        layer.on('click', (e) =>
                            applyHighlight(stairstatue, layer, e, feature, 'stairstatue')
                        );
                        const p = feature.properties || {};
                        const nameForLabel = (currentLang === 'en') ? (p.int_name || p.name || '') : (p.name || '');
                        layer._label = createLabelForFeature(feature, nameForLabel);
                        if (layer._label) { layer._label.addTo(map); window._labelLayers.push({ layer, feature }); }
                    }
                }
            }).addTo(map);

            // (2) .addTo(map) 바로 다음 줄: 레이어 그룹 키 지정
            stairstatue._desc_key = 'stairstatue';
        }).catch(console.error);


        // Playground (partial interactive: fid === 7)
        fetch('./data/playground.geojson').then(r => r.json()).then(data => {
            const playground = L.geoJSON(data, {
                renderer: svgRenderer,
                style: { color: '#a8a09a', weight: 0, fillColor: '#cbdfac', fillOpacity: 1 },
                onEachFeature: (feature, layer) => {
                    if (feature.properties?.fid === 7) {
                        rememberStyle(layer);
                        layer.on('click', (e) => applyHighlight(playground, layer, e, feature, 'playground'));
                        const p = feature.properties || {};
                        const nameForLabel = (currentLang === 'en') ? (p.int_name || p.name || '') : (p.name || '');
                        layer._label = createLabelForFeature(feature, nameForLabel);
                        if (layer._label) { layer._label.addTo(map); window._labelLayers.push({ layer, feature }); }
                    }
                }
            }).addTo(map);
            playground._desc_key = 'playground';
        }).catch(console.error);

        // Roads / Pedestrian (non-interactive)
        fetch('./data/road.geojson').then(r => r.json()).then(data => {
            L.geoJSON(data, {
                renderer: svgRenderer,
                interactive: false, style: { color: '#ffffff', weight: 4, opacity: 1 }
            }).addTo(map);
        }).catch(console.error);
        fetch('./data/pedestrian.geojson').then(r => r.json()).then(data => {
            L.geoJSON(data, {
                renderer: svgRenderer,
                interactive: false, style: { color: '#ffffff', weight: 1, opacity: 1, dashArray: '5,5' }
            }).addTo(map);
        }).catch(console.error);

        // Points (Parkinglot & Gate) — show at zoom >= 18
        let parkinglotLayer, gateLayer;
        const toggleByZoom = () => {
            const show = map.getZoom() >= 18;
            if (parkinglotLayer) { if (show && !map.hasLayer(parkinglotLayer)) map.addLayer(parkinglotLayer); else if (!show && map.hasLayer(parkinglotLayer)) map.removeLayer(parkinglotLayer); }
            if (gateLayer) { if (show && !map.hasLayer(gateLayer)) map.addLayer(gateLayer); else if (!show && map.hasLayer(gateLayer)) map.removeLayer(gateLayer); }
        };
        map.on('zoomend', toggleByZoom);

        // Parkinglot
        fetch(resolveAsset('./data/parkinglot.geojson'), { cache: 'no-store' })
            .then(r => r.json())
            .then(data => {
                const parkingIcon = L.divIcon({
                    className: 'parking-icon',
                    html: 'P',
                    iconSize: [20, 20],
                    iconAnchor: [14, 1]
                });

                parkinglotLayer = L.geoJSON(data, {
                    pointToLayer: (_, latlng) => L.marker(latlng, { icon: parkingIcon }),
                    onEachFeature: (feature, layer) => {
                        layer.on('click', e =>
                            applyHighlight(parkinglotLayer, layer, e, feature, 'parkinglot')
                        );
                    }
                });
                // 레이어 그룹 키 지정 (이 키로 parkinglot_desc.json을 매칭)
                parkinglotLayer._desc_key = 'parkinglot';

                // 생성 직후 현재 줌 기준으로 표시/숨김 반영
                toggleByZoom();

                // (선택) 첫 클릭 지연 방지: 설명 JSON 미리 로드
                ensureDescLoaded('parkinglot');
            })
            .catch(console.error);


        // Gate
        fetch(resolveAsset('./data/gate.geojson'), { cache: 'no-store' })
            .then(r => r.json())
            .then(data => {
                const gateIcon = L.divIcon({
                    className: 'gate-icon',
                    html: '&#x1F3DB;',
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });

                gateLayer = L.geoJSON(data, {
                    pointToLayer: (_, latlng) => L.marker(latlng, { icon: gateIcon }),
                    onEachFeature: (feature, layer) => {
                        rememberStyle(layer);
                        layer.on('click', e =>
                            applyHighlight(gateLayer, layer, e, feature, 'gate')
                        );
                    }
                });
                // 레이어 그룹 키 지정 (이 키로 gate_desc.json을 매칭)
                gateLayer._desc_key = 'gate';

                // 생성 직후 현재 줌 기준으로 표시/숨김 반영
                toggleByZoom();

                // (선택) 첫 클릭 지연 방지: 설명 JSON 미리 로드
                ensureDescLoaded('gate');
            })
            .catch(console.error);

    </script>
</body>

</html>